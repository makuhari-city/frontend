(this.webpackJsonpfrontend=this.webpackJsonpfrontend||[]).push([[0],{114:function(e,t,n){},116:function(e,t,n){"use strict";n.r(t);var a,o=n(1),i=n.n(o),r=n(43),s=n.n(r),c=(n(50),n(3)),l=n(118),h=n(0),u=function(){return Object(h.jsx)("header",{children:Object(h.jsx)("nav",{className:"flex items-center justify-between p-6 container mx-auto mt-32 mb-32 max-w-screen-lg font-bold",children:Object(h.jsxs)("a",{href:"/",className:"hover:underline",children:["METACITY",Object(h.jsx)("br",{}),"\u300c\u591a\u5c64\u90fd\u5e02\u300d\u5e55\u5f35\u5e02"]})})})},d=n(10),f=n(44),p=n(45),m=Object(d.GLSL)(a||(a=Object(p.a)(['\nprecision highp float;\nvarying vec2 uv;\nuniform float iTime;\nuniform float iResolutionX;\nuniform float iResolutionY;\n\n// A documented, altered, recolored version of "Seascape".\n// The famous original at:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// "Seascape" by Alexander Alekseev aka TDM - 2014\n// Commenting added by bteitler\n//  HSV/color adjustments and additional commenting by CaliCoastReplay - 2016\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float PI\t \t= 3.14159265358;\n\n// Can you explain these epsilons to a wide graphics audience?  YOUR comment could go here.\nconst float EPSILON\t= 1e-3;\n#define  EPSILON_NRM (0.5/iResolutionX)\n\n// Constant indicaing the number of steps taken while marching the light ray.  \nconst int NUM_STEPS = 6;\n\n//Constants relating to the iteration of the heightmap for the wave, another part of the rendering\n//process.\nconst int ITER_GEOMETRY = 2;\nconst int ITER_FRAGMENT = 3;\n\n// Constants that represent physical characteristics of the sea, can and should be changed and \n//  played with\nconst float SEA_HEIGHT = 0.45;\nconst float SEA_CHOPPY = 3.0;\nconst float SEA_SPEED = 0.3;\nconst float SEA_FREQ = 0.24;\n// const vec3 SEA_BASE = vec3(0.11,0.19,0.22);\nconst vec3 SEA_BASE = vec3(0.1796875, 0.203125, 0.25);\nconst vec3 SEA_WATER_COLOR = vec3(0.55,0.9,0.7)*0.6;\n#define SEA_TIME (iTime * SEA_SPEED)\n\n//Matrix to permute the water surface into a complex, realistic form\nmat2 octave_m = mat2(1.7,1.2,-1.2,1.4);\n\n//Space bar key constant\nconst float KEY_SP    = 32.5/256.0;\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts red-green-blue color to hue-saturation-value color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts hue-saturation-value color to red-green-blue color\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling "GLSL hash function" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*83758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the "hash" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the "smoothstep" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction\'s Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,0.5);\n    ret.y = 1.0-e.y;\n    ret.z = 1.0-e.y;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn\'t the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation ("sea_octave") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don\'t need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \t//d += sea_octave((uv-SEA_TIME)*freq,choppy);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: "Twist" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *=  octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the "waves within waves" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation ("sea_octave") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don\'t need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        \n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: "Twist" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m/1.2;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the "waves within waves" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.45;\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n))*0.99;    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,120.0) * SEA_WATER_COLOR * 0.27; \n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.15 * atten;\n    \n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,90.0))*0.075;\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the "map" / "map_detailed" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I\'m assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won\'t have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n}\n\n\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    // float tx = 500.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n    float tx = 60.0;\n    // bteitler: At a really far away distance along the ray, what is it\'s height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven\'t hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n// bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid main() {\n    // bteitler: 2D Pixel location passed in as raw pixel, let\'s divide by resolution\n    // to convert to coordinates between 0 and 1\n    // vec2 uv = uv.xy / uv.xy;\n    float time = iTime * 0.3; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n    vec3 ang = vec3(PI,PI*0.7,0.4);\n    \n    // bteitler: Calculate the "origin" of the camera in world space based on time.  Camera is located\n    // at height 3.5 atx 0 (zero), and flies over the ocean in the z axis over time.\n\t// LOCATION\n    vec3 ori = vec3(0.0,20.0,time*3.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location ("ori") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    //  CaliCoastReplay :  Adjusted slightly to a lower focal length.  Seems to dramatize the scene.\n    vec3 dir = normalize(vec3(uv.xy,-1.6)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n   //  dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle "ang".  "fromEuler" just calculates a rotation matrix from a vector of angles.\n    // if you remove the " * fromEuler(ang)" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel\'s ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different "resolution" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // CaliCoastReplay:  Get the sky and sea colors\n\tvec3 skyColor = getSkyColor(dir);\n    vec3 seaColor = getSeaColor(p,n,light,dir,dist);\n    \n    //Sea/sky preprocessing\n    \n    //CaliCoastReplay:  A distance falloff for the sea color.   Drastically darkens the sea, \n    //this will be reversed later based on day/night.\n    seaColor /= sqrt(sqrt(length(dist))) ;\n    \n    \n    //CaliCoastReplay\t \n    seaColor *= sqrt(sqrt(seaColor)) * 3.0;\n    \n    //CaliCoastReplay:  A rather hacky manipulation of the high-value regions in the image that seems\n    //to add a subtle charm and "sheen" and foamy effect to high value regions through subtle darkening,\n    //but it is hacky, and not physically modeled at all.  \n    vec3 seaHsv = rgb2hsv(seaColor);\n    if (seaHsv.z > .75 && length(dist) < 50.0)\n       seaHsv.z -= (0.9 - seaHsv.z) * 1.3;\n    seaColor = hsv2rgb(seaHsv);\n    \n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    \n    vec3 color = mix(\n        skyColor,\n        seaColor,\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as "fog" that gets thicker in the distance\n    );\n        \n    gl_FragColor = vec4(pow(color,vec3(0.95)), 1.0);     \n}']))),b=d.Shaders.create({ocean:{frag:m}}),v=function(e){var t=e.iTime,n=e.iResolutionX,a=e.iResolutionY;return Object(h.jsx)(d.Node,{shader:b.ocean,uniforms:{iTime:t,iResolutionX:n,iResolutionY:a}})},g=function(){var e=Object(o.useState)(1280),t=Object(c.a)(e,2),n=t[0],a=t[1],i=Object(o.useState)(720),r=Object(c.a)(i,2),s=r[0],l=r[1],u=Object(o.useState)(0),d=Object(c.a)(u,2),p=d[0],m=d[1],b=Object(o.useRef)(),g=Object(o.useRef)(),y=function e(t){void 0==g.current&&(g.current=t);var n=t-g.current;n>100/6&&(m((function(e){return e+n/1e3})),g.current=t),b.current=requestAnimationFrame(e)};return Object(o.useEffect)((function(){a(window.innerWidth),l(window.innerHeight),b.current=requestAnimationFrame(y);var e=function(){a(window.innerWidth),l(window.innerHeight)};return window.addEventListener("resize",e),function(){cancelAnimationFrame(b.current),window.removeEventListener("resize",e)}}),[]),Object(h.jsx)("div",{style:{position:"fixed",zIndex:-1,top:0,left:0,width:"100%",height:"100%"},children:Object(h.jsx)(f.Surface,{width:n,height:s,children:Object(h.jsx)(v,{iTime:p,iResolutionX:n,iResolutionY:s})})})},y=function(){var e=Object(o.useState)(),t=Object(c.a)(e,2),n=t[0],a=t[1],i=Object(o.useState)(""),r=Object(c.a)(i,2),s=r[0],d=r[1],f=Object(o.useState)(!1),p=Object(c.a)(f,2),m=p[0],b=p[1],v=Object(o.useState)("#eceff4"),y=Object(c.a)(v,2),w=y[0],x=y[1],j=function(e){if(""!==e){var t=function(e){return{uid:Object(l.a)(),name:e}}(e);!function(e){localStorage.setItem("user",JSON.stringify(e))}(t),a(t),b(!0),x("#".concat(t.uid.substring(0,5))),d("")}else console.error("username is empty")};return Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)(u,{}),Object(h.jsxs)("div",{className:"container mx-auto px-6 py-16 max-w-screen-lg bg-nord-0 bg-opacity-90 rounded",children:[Object(h.jsx)("div",{className:"font-bold mb-3",children:"Citizen Registration \u4f4f\u6c11\u767b\u9332"}),Object(h.jsx)("div",{className:"font-thin text-xs mb-8",children:"\u5e55\u5f35\u5e02\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u53c2\u52a0\u306b\u306f\u4f4f\u6c11\u767b\u9332\u304c\u5fc5\u8981\u3067\u3059\u3002"}),Object(h.jsxs)("div",{className:"grid grid-cols-2 w-3/5 justify-items-end",children:[Object(h.jsx)("div",{className:"self-center",children:"username:"}),Object(h.jsx)("div",{children:Object(h.jsx)("input",{type:"text",placeholder:"johndoe",name:"name",value:s,className:"px-6 py-3 placeholder-gray-400 text-nord-0 relative bg-nord-4 rounded text-sm border border-nord-1 outline-none focus:outline-none focus:ring",onKeyUp:function(e){"Enter"===e.key&&j(s)},onChange:function(e){return t=e.target.value,void d(t);var t}})})]}),Object(h.jsx)("div",{className:"w-3/5 grid justify-items-end mt-16",children:Object(h.jsx)("button",{onClick:function(){j(s)},className:"transition duration-150 ease-in bg-nord-1 hover:bg-nord-2 text-nord-4 border border-nord-5 font-bold py-2 px-6 rounded",children:"register"})}),m&&Object(h.jsxs)("div",{className:"w-3/5 grid grid-justify-items-end",children:[Object(h.jsxs)("div",{className:"text-nord-9 my-4",children:["'",n.name,"' created with id ",Object(h.jsx)("span",{style:{color:"".concat({color:w})},children:n.uid.substring(0,6)})]}),Object(h.jsx)("a",{href:"./",className:"ease-in duration-150 bg-nord-1 hover:bg-nord-2 text-nord-4 font-bold py-2 px-6 rounded text-center",children:"go to list"})]})]}),Object(h.jsx)(g,{})]})},w=(n(114),n(2)),x=n.n(w),j=n(4),B="https://vote.metacity.jp",D="db",O=function(){var e=Object(j.a)(x.a.mark((function e(){var t,n;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("".concat(B,"/").concat(D,"/list/"));case 2:return t=e.sent,e.next=5,t.json();case 5:return n=e.sent,e.abrupt("return",n);case 7:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}(),A=function(){var e=Object(j.a)(x.a.mark((function e(t){var n,a;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("".concat(B,"/").concat(D,"/header/").concat(t));case 2:return n=e.sent,e.next=5,n.json();case 5:return a=e.sent,e.abrupt("return",a);case 7:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),C=function(){var e=Object(j.a)(x.a.mark((function e(t){var n,a;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("".concat(B,"/").concat(D,"/topic/").concat(t,"/"));case 2:return n=e.sent,e.next=5,n.json();case 5:return a=e.sent,e.abrupt("return",a);case 7:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),k=function(){var e=Object(j.a)(x.a.mark((function e(t){var n,a;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("".concat(B,"/").concat(D,"/result/").concat(t,"/"));case 2:return n=e.sent,e.next=5,n.json();case 5:if(a=e.sent){e.next=10;break}return e.abrupt("return",null);case 10:return e.abrupt("return",a);case 11:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),S=function(){var e=Object(j.a)(x.a.mark((function e(t,n,a,o){var i,r,s;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return i={id:n,name:a,vote:o},e.next=3,fetch("".concat(B,"/").concat(D,"/topic/update/").concat(t,"/delegate/"),{method:"POST",body:JSON.stringify(i),headers:{"Content-Type":"application/json"}});case 3:return r=e.sent,e.next=6,r.json();case 6:s=e.sent,console.log(s);case 8:case"end":return e.stop()}}),e)})));return function(t,n,a,o){return e.apply(this,arguments)}}(),E=function(e){e.user;var t=Object(o.useState)([]),n=Object(c.a)(t,2),a=n[0],i=n[1],r=Object(o.useState)(!0),s=Object(c.a)(r,2),l=s[0],d=s[1],f=Object(o.useState)(!0),p=Object(c.a)(f,2),m=p[0],b=p[1];Object(o.useEffect)((function(){(function(){var e=Object(j.a)(x.a.mark((function e(){var t;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,O();case 2:t=e.sent,d(!1),t.length>0&&(b(!1),i(t));case 5:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}})()()}),[]);var v;return Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)(u,{}),Object(h.jsx)("div",{className:"container max-w-screen-lg py-8 mx-auto bg-nord-0 bg-opacity-90 min-h-1/4 rounded",children:l?Object(h.jsx)("div",{className:"p-4",children:"Loading topics..."}):m?Object(h.jsx)("div",{className:"p-4",children:"0 topics. Nothing to vote."}):(v=a,Object(h.jsxs)("div",{children:[Object(h.jsx)("h1",{className:"px-4 text-bold",children:"topics:"}),Object(h.jsx)("ul",{className:"p-4 w-3/5",children:v.map((function(e){return Object(h.jsx)("li",{className:"mb-1",children:Object(h.jsx)("a",{className:"duration-500 ease-out p-4 flex space-x-4 bg-nord-1 hover:bg-nord-2",href:"?t=".concat(e.id),children:e.title})})}))})]}))}),Object(h.jsx)(g,{})]})},T=n(15),N=n(16),_=function(e){var t=e.info,n=e.initialVotes,a=e.user,i=e.id,r=Object(o.useState)(n),s=Object(c.a)(r,2),l=s[0],u=s[1],d=function(e){return function(t){var n=parseFloat(t.target.value);n||(n=0),n<1&&(n=0);var a=Object(N.a)(Object(N.a)({},l),{},Object(T.a)({},e,n));u(a)}},f=function(e,t){return function(){var n=t?1:-1,a=l[e]+n;a<0&&(a=0);var o=Object(N.a)(Object(N.a)({},l),{},Object(T.a)({},e,a));u(o)}};return Object(h.jsxs)("div",{className:"container mx-auto max-w-screen-lg p-3",children:[Object(h.jsx)("div",{className:"w-3/5",children:Object.keys(l).map((function(e){return Object(h.jsxs)("div",{className:"ml-3 mb-3 p-2 flex flex-row bg-nord-0 bg-opacity-50 rounded",children:[Object(h.jsx)("div",{className:"flex items-center justify-center font-medium",children:(n=e,Object.keys(t.delegates).includes(n)?t.delegates[n]:t.policies[n])}),Object(h.jsx)("div",{className:"flex-grow"}),Object(h.jsxs)("div",{className:"inline-flex",children:[Object(h.jsx)("button",{className:"font-bold px-3 bg-nord-1 hover:bg-nord-3 rounded-l",onClick:f(e,!1),children:"-"}),Object(h.jsx)("input",{className:"px-3 py-1 w-12 text-nord-0 bg-nord-4 font-medium",onChange:d(e),value:l[e]}),Object(h.jsx)("button",{className:"font-bold px-3 bg-nord-1 hover:bg-nord-3 rounded-r",onClick:f(e,!0),children:"+"})]})]});var n}))}),Object(h.jsx)("div",{className:"mt-3 w-3/5 grid justify-items-end",children:Object(h.jsx)("button",{className:"p-2 rounded border bg-nord-9 font-bold text-nord-0 hover:bg-nord-10 bg-opacity-80 duration-500 ease-in",onClick:function(){(function(){var e=Object(j.a)(x.a.mark((function e(){return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",S(i,a.uid,a.name,l));case 1:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}})()()},children:"Update vote"})})]})},R=function(){var e=Object(j.a)(x.a.mark((function e(t){var n,a;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("".concat("https://vote.metacity.jp","/rpc/"),{method:"POST",body:JSON.stringify(t),headers:{"Content-Type":"application/json"}});case 2:return n=e.sent,e.next=5,n.json();case 5:return a=e.sent,e.abrupt("return",a);case 7:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),q=function(e){var t=e.info,n=e.hash,a=Object(o.useState)(""),i=Object(c.a)(a,2),r=i[0],s=i[1];return Object(o.useEffect)((function(){(function(){var e=Object(j.a)(x.a.mark((function e(){var n,a,o,i;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,A(t.id);case 2:return n=e.sent,e.next=5,k(n.hash);case 5:if("error"!==(a=e.sent).status){e.next=17;break}return s("result not found in database. sending calculation result to `vote`."),e.next=10,C(n.id);case 10:return o=e.sent,e.next=13,R(o);case 13:i=e.sent,s(JSON.stringify(i,null,2)),e.next=18;break;case 17:s(JSON.stringify(a,null,2));case 18:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}})()()}),[n,t]),Object(h.jsx)(h.Fragment,{children:Object(h.jsxs)("details",{className:"text-sm p-2 mt-4",children:[Object(h.jsx)("summary",{className:"p-3 bg-nord-0 bg-opacity-10 border border-nord-3 rounded w-3/5",children:"Results"}),Object(h.jsx)("pre",{className:"bg-nord-0 bg-opacity-90 text-xs p-3 mt-3 rounded w-3/5",children:r}),Object(h.jsx)("button",{className:"mt-3 mb-8 p-2 rounded border bg-nord-9 font-bold text-nord-0 hover:bg-nord-10 bg-opacity-80 duration-500 ease-in",children:"Update"})]})})},z=function(e){var t=e.info,n=e.user,a=e.hash;return Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)(u,{}),Object(h.jsxs)("div",{className:"container max-w-screen-lg mx-auto",children:[Object(h.jsx)("h1",{className:"font-bold p-2",children:t.title}),Object(h.jsxs)("details",{className:"text-sm p-2 mb-4",children:[Object(h.jsx)("summary",{className:"p-3 bg-nord-0 bg-opacity-10 border border-nord-3 rounded w-3/5",children:"Details"}),Object(h.jsx)("p",{className:"bg-nord-0 bg-opacity-90 text-xs p-3 mt-3 rounded w-3/5",children:t.description})]}),Object(h.jsxs)("details",{open:!0,className:"p-2",children:[Object(h.jsx)("summary",{className:"p-3 bg-nord-0 bg-opacity-10 border border-nord-3 rounded w-3/5 text-sm",children:"Votes"}),Object(h.jsx)(_,{info:t,initialVotes:function(){var e={};Object.keys(t.policies).forEach((function(t){return e[t]=0})),Object.keys(t.delegates).forEach((function(t){return e[t]=0}));var a=t.votes[n.uid];return a&&Object.keys(a).forEach((function(t){return e[t]=a[t]})),delete e[n.uid],e}(),user:n,id:t.id})]}),Object(h.jsx)(q,{info:t,hash:a})]}),Object(h.jsx)(g,{})]})},I=function(e){var t=e.id,n=e.user,a=Object(o.useState)(null),i=Object(c.a)(a,2),r=i[0],s=i[1],l=Object(o.useState)(""),d=Object(c.a)(l,2),f=d[0],p=d[1];return Object(o.useEffect)((function(){(function(){var e=Object(j.a)(x.a.mark((function e(){var n,a;return x.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,C(t);case 2:return n=e.sent,e.next=5,A(t);case 5:a=e.sent,p(a.hash),s(n);case 8:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}})()()}),[t]),r?Object(h.jsx)(z,{info:r,user:n,hash:f}):Object(h.jsxs)("div",{children:[Object(h.jsx)(u,{}),Object(h.jsxs)("div",{className:"container mx-auto max-w-screen-lg p-2",children:["Loading Topic (#",t.substring(0,5),") information..."]})]})},L=function(e){var t=window.location.search;return new URLSearchParams(t).get(e)},Y=function(){var e=Object(o.useState)(null),t=Object(c.a)(e,2),n=t[0],a=t[1];if(Object(o.useEffect)((function(){var e=function(){var e=localStorage.getItem("user");return e?JSON.parse(e):null}();a(e)}),[]),!n)return Object(h.jsx)(y,{});var i=L("t");return i?Object(h.jsx)(I,{id:i,user:n}):Object(h.jsx)(E,{user:n})},P=function(e){e&&e instanceof Function&&n.e(3).then(n.bind(null,119)).then((function(t){var n=t.getCLS,a=t.getFID,o=t.getFCP,i=t.getLCP,r=t.getTTFB;n(e),a(e),o(e),i(e),r(e)}))};s.a.render(Object(h.jsx)(i.a.StrictMode,{children:Object(h.jsx)(Y,{})}),document.getElementById("root")),P()},50:function(e,t,n){}},[[116,1,2]]]);
//# sourceMappingURL=main.fda84522.chunk.js.map