{"version":3,"sources":["TitleBar.tsx","shader.tsx","Canvas.tsx","MakeNewUser.tsx","user.tsx","database.tsx","ListView.tsx","VotingForms.tsx","vote.tsx","VotingResults.tsx","VotingInfo.tsx","VotingSession.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["TitleBar","className","href","oceanShader","GLSL","shaders","Shaders","create","ocean","frag","Ocean","iTime","iResolutionX","iResolutionY","shader","uniforms","Canvas","useState","width","setWidth","height","setHeight","setITime","requestRef","useRef","prevTime","animate","ts","undefined","current","elapsed","prevITime","requestAnimationFrame","useEffect","window","innerWidth","innerHeight","resizeListener","addEventListener","cancelAnimationFrame","removeEventListener","style","position","zIndex","top","left","MakeNewUser","newUser","setNewUser","nameInput","setNameInput","isUserSaved","setIsUserSaved","color","setColor","addUser","name","user","uid","uuidv4","createUser","localStorage","setItem","JSON","stringify","saveUser","substring","console","error","type","placeholder","value","onKeyUp","event","key","onChange","e","target","onClick","baseUrl","prefix","fetchList","a","fetch","res","json","list","fetchHeader","id","header","fetchTopicData","info","fetchResult","hash","updateVote","topic_id","vote","newVote","method","body","headers","log","ListView","setList","isLoading","setIsLoading","isEmpty","setIsEmpty","newList","length","getList","items","map","item","title","VotingForms","initialVotes","votes","setVotes","handleChange","uuid","parseFloat","newVotes","handleIncrementValueButton","inc","newvalue","newvotes","Object","keys","k","delegates","includes","policies","update","topicData","response","data","VotingResults","result","setResult","fetched","status","latest","calculated","checkResult","VotingInfo","description","open","options","forEach","to","userVotes","getOptions","VotingSession","setInfo","setHash","latestInfo","getInfo","checkParams","p","cUrl","location","search","URLSearchParams","get","App","setUser","savedUser","userData","getItem","parse","checkSavedUser","topicId","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fda84522.chunk.js","sourcesContent":["const TitleBar = () => (\n  <header>\n    <nav className=\"flex items-center justify-between p-6 container mx-auto mt-32 mb-32 max-w-screen-lg font-bold\">\n      <a href=\"/\" className=\"hover:underline\">\n\t\t  METACITY<br/>\n\t\t\t「多層都市」幕張市\n      </a>\n    </nav>\n  </header>\n);\n\nexport default TitleBar;\n","import { GLSL } from \"gl-react\";\n\nexport interface OceanUniforms {\n  iTime: number;\n  iResolutionX: number;\n  iResolutionY: number;\n}\n\nexport const oceanShader = GLSL`\nprecision highp float;\nvarying vec2 uv;\nuniform float iTime;\nuniform float iResolutionX;\nuniform float iResolutionY;\n\n// A documented, altered, recolored version of \"Seascape\".\n// The famous original at:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// Commenting added by bteitler\n//  HSV/color adjustments and additional commenting by CaliCoastReplay - 2016\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float PI\t \t= 3.14159265358;\n\n// Can you explain these epsilons to a wide graphics audience?  YOUR comment could go here.\nconst float EPSILON\t= 1e-3;\n#define  EPSILON_NRM (0.5/iResolutionX)\n\n// Constant indicaing the number of steps taken while marching the light ray.  \nconst int NUM_STEPS = 6;\n\n//Constants relating to the iteration of the heightmap for the wave, another part of the rendering\n//process.\nconst int ITER_GEOMETRY = 2;\nconst int ITER_FRAGMENT = 3;\n\n// Constants that represent physical characteristics of the sea, can and should be changed and \n//  played with\nconst float SEA_HEIGHT = 0.45;\nconst float SEA_CHOPPY = 3.0;\nconst float SEA_SPEED = 0.3;\nconst float SEA_FREQ = 0.24;\n// const vec3 SEA_BASE = vec3(0.11,0.19,0.22);\nconst vec3 SEA_BASE = vec3(0.1796875, 0.203125, 0.25);\nconst vec3 SEA_WATER_COLOR = vec3(0.55,0.9,0.7)*0.6;\n#define SEA_TIME (iTime * SEA_SPEED)\n\n//Matrix to permute the water surface into a complex, realistic form\nmat2 octave_m = mat2(1.7,1.2,-1.2,1.4);\n\n//Space bar key constant\nconst float KEY_SP    = 32.5/256.0;\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts red-green-blue color to hue-saturation-value color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts hue-saturation-value color to red-green-blue color\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*83758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,0.5);\n    ret.y = 1.0-e.y;\n    ret.z = 1.0-e.y;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \t//d += sea_octave((uv-SEA_TIME)*freq,choppy);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *=  octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        \n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m/1.2;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.45;\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n))*0.99;    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,120.0) * SEA_WATER_COLOR * 0.27; \n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.15 * atten;\n    \n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,90.0))*0.075;\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n}\n\n\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    // float tx = 500.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n    float tx = 60.0;\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n// bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid main() {\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    // vec2 uv = uv.xy / uv.xy;\n    float time = iTime * 0.3; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n    vec3 ang = vec3(PI,PI*0.7,0.4);\n    \n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5 atx 0 (zero), and flies over the ocean in the z axis over time.\n\t// LOCATION\n    vec3 ori = vec3(0.0,20.0,time*3.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    //  CaliCoastReplay :  Adjusted slightly to a lower focal length.  Seems to dramatize the scene.\n    vec3 dir = normalize(vec3(uv.xy,-1.6)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n   //  dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // CaliCoastReplay:  Get the sky and sea colors\n\tvec3 skyColor = getSkyColor(dir);\n    vec3 seaColor = getSeaColor(p,n,light,dir,dist);\n    \n    //Sea/sky preprocessing\n    \n    //CaliCoastReplay:  A distance falloff for the sea color.   Drastically darkens the sea, \n    //this will be reversed later based on day/night.\n    seaColor /= sqrt(sqrt(length(dist))) ;\n    \n    \n    //CaliCoastReplay\t \n    seaColor *= sqrt(sqrt(seaColor)) * 3.0;\n    \n    //CaliCoastReplay:  A rather hacky manipulation of the high-value regions in the image that seems\n    //to add a subtle charm and \"sheen\" and foamy effect to high value regions through subtle darkening,\n    //but it is hacky, and not physically modeled at all.  \n    vec3 seaHsv = rgb2hsv(seaColor);\n    if (seaHsv.z > .75 && length(dist) < 50.0)\n       seaHsv.z -= (0.9 - seaHsv.z) * 1.3;\n    seaColor = hsv2rgb(seaHsv);\n    \n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    \n    vec3 color = mix(\n        skyColor,\n        seaColor,\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n        \n    gl_FragColor = vec4(pow(color,vec3(0.95)), 1.0);     \n}`;\n","import { Shaders, Node } from \"gl-react\";\nimport { Surface } from \"gl-react-dom\";\nimport { oceanShader, OceanUniforms } from \"./shader\";\nimport { useEffect, useRef, useState } from \"react\";\nconst shaders = Shaders.create({\n  ocean: {\n    frag: oceanShader,\n  },\n});\n\nconst Ocean = ({ iTime, iResolutionX, iResolutionY }: OceanUniforms) => {\n  return (\n    <Node\n      shader={shaders.ocean}\n      uniforms={{ iTime, iResolutionX, iResolutionY }}\n    />\n  );\n};\n\nconst Canvas = () => {\n  const [width, setWidth] = useState(1280);\n  const [height, setHeight] = useState(720);\n  const [iTime, setITime] = useState(0);\n\n  const requestRef = useRef<undefined | number>();\n  const prevTime = useRef<undefined | number>();\n\n  const animate = (ts: number) => {\n    if (prevTime.current == undefined) {\n      prevTime.current = ts;\n    }\n\n    const elapsed = ts - prevTime.current;\n\n    if (elapsed > 100.0 / 6.0) {\n      setITime((prevITime) => prevITime + elapsed / 1000.0);\n      prevTime.current = ts;\n    }\n\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    setWidth(window.innerWidth);\n    setHeight(window.innerHeight);\n    requestRef.current = requestAnimationFrame(animate);\n\n    const resizeListener = () => {\n      setWidth(window.innerWidth);\n      setHeight(window.innerHeight);\n    };\n\n    window.addEventListener(\"resize\", resizeListener);\n\n    return () => {\n      cancelAnimationFrame(requestRef.current!);\n      window.removeEventListener(\"resize\", resizeListener);\n    };\n  }, []);\n\n  return (\n\t  <div style={{ position: \"fixed\", zIndex: -1, top: 0, left: 0, width:\"100%\", height:\"100%\" }}>\n\t\t  <Surface width={width} height={height}>\n        <Ocean iTime={iTime} iResolutionX={width} iResolutionY={height} />\n      </Surface>\n    </div>\n  );\n};\n\nexport default Canvas;\n","import { useState } from \"react\";\nimport { createUser, saveUser, User } from \"./user\";\nimport TitleBar from \"./TitleBar\";\nimport Canvas from \"./Canvas\";\n\nconst MakeNewUser = () => {\n  const [newUser, setNewUser] = useState<undefined | User>();\n  const [nameInput, setNameInput] = useState(\"\");\n  const [isUserSaved, setIsUserSaved] = useState(false);\n  const [color, setColor] = useState(\"#eceff4\");\n\n  const handleKey = (event: { key: string }) => {\n    if (event.key === \"Enter\") {\n      addUser(nameInput);\n    }\n  };\n\n  const addUser = (name: string) => {\n    if (name !== \"\") {\n      const user = createUser(name);\n      saveUser(user); // saves this to local storage\n\t  setNewUser(user);\n      setIsUserSaved(true);\n\t  setColor(`#${user.uid.substring(0,5)}`);\n\t  setNameInput(\"\");\n    } else {\n      console.error(\"username is empty\");\n    }\n  };\n\n  const handleChange = (value: string) => {\n    setNameInput(value);\n  };\n\n  return (\n    <>\n      <TitleBar />\n      <div className=\"container mx-auto px-6 py-16 max-w-screen-lg bg-nord-0 bg-opacity-90 rounded\">\n        <div className=\"font-bold mb-3\">Citizen Registration 住民登録</div>\n\t\t  <div className=\"font-thin text-xs mb-8\">幕張市プロジェクト参加には住民登録が必要です。</div>\n\n        <div className=\"grid grid-cols-2 w-3/5 justify-items-end\">\n\t\t\t<div className=\"self-center\">username:</div>\n          <div>\n            <input\n              type=\"text\"\n              placeholder=\"johndoe\"\n              name=\"name\"\n\t\t\t\tvalue={nameInput}\n              className=\"px-6 py-3 placeholder-gray-400 text-nord-0 relative bg-nord-4 rounded text-sm border border-nord-1 outline-none focus:outline-none focus:ring\"\n              onKeyUp={handleKey}\n              onChange={(e) => handleChange(e.target.value)}\n            />\n          </div>\n        </div>\n\n        <div className=\"w-3/5 grid justify-items-end mt-16\">\n          <button\n            onClick={() => {\n              addUser(nameInput);\n            }}\n            className=\"transition duration-150 ease-in bg-nord-1 hover:bg-nord-2 text-nord-4 border border-nord-5 font-bold py-2 px-6 rounded\"\n          >\n            register\n          </button>\n        </div>\n\n        {isUserSaved && (\n          <div className=\"w-3/5 grid grid-justify-items-end\">\n\t\t\t<div className=\"text-nord-9 my-4\">\n\t\t\t\t'{newUser!.name}' created with id <span style={{color:`${{color}}`}}>{newUser!.uid.substring(0,6)}</span>\n\t\t\t</div>\n            <a href=\"./\" className=\"ease-in duration-150 bg-nord-1 hover:bg-nord-2 text-nord-4 font-bold py-2 px-6 rounded text-center\" >go to list</a>\n          </div>\n        )}\n      </div>\n      <Canvas />\n    </>\n  );\n};\n\nexport default MakeNewUser;\n","import { v4 as uuidv4 } from \"uuid\";\n\nexport interface User {\n  name: string;\n  uid: string;\n}\n\nexport const createUser = (name: string): User => {\n  return { uid: uuidv4(), name } as User;\n};\n\nexport const saveUser = (user: User) => {\n  localStorage.setItem(\"user\", JSON.stringify(user));\n};\n\nexport const checkSavedUser = (): null | User => {\n  const userData = localStorage.getItem(\"user\");\n  if (userData) {\n    const user: User = JSON.parse(userData);\n    return user;\n  } else {\n    return null;\n  }\n};\n\n\n","const baseUrl = \"https://vote.metacity.jp\";\nconst prefix = \"db\";\n\nexport interface ITopicHeader {\n  id: string;\n  hash: string;\n  title: string;\n}\n\nexport interface ITopicData {\n  id: string;\n  title: string;\n  description: string;\n  delegates: { [id: string]: string };\n  policies: { [id: string]: string };\n  votes: { [src: string]: { [dest: string]: number } };\n}\n\nexport const fetchList = async (): Promise<ITopicHeader[]> => {\n  const res = await fetch(`${baseUrl}/${prefix}/list/`);\n  const list: ITopicHeader[] = await res.json();\n  return list;\n};\n\nexport const fetchHeader = async (id: string): Promise<ITopicHeader> => {\n  const res = await fetch(`${baseUrl}/${prefix}/header/${id}`);\n  const header: ITopicHeader = await res.json();\n  return header;\n};\n\nexport const fetchTopicData = async (id: string): Promise<ITopicData> => {\n  const res = await fetch(`${baseUrl}/${prefix}/topic/${id}/`);\n  const info: any = await res.json();\n  return info as ITopicData;\n};\n\nexport const fetchResult = async (hash: string): Promise<any | null> => {\n  const res = await fetch(`${baseUrl}/${prefix}/result/${hash}/`);\n  const info: any = await res.json();\n  if (!info) {\n    return null;\n  } else {\n    return info;\n  }\n};\n\nexport const postResult = async (hash: string, result: any) => {\n  const res = await fetch(`${baseUrl}/${prefix}/result/${hash}/`, {\n    method: \"POST\",\n    body: JSON.stringify(result),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n\n  let info = await res.json();\n  console.log(info);\n};\n\nexport const updateVote = async (\n  topic_id: string,\n  id: string,\n  name: string,\n  vote: { [to: string]: number }\n) => {\n  const newVote = {\n    id,\n    name,\n    vote,\n  };\n\n  const res = await fetch(\n    `${baseUrl}/${prefix}/topic/update/${topic_id}/delegate/`,\n    {\n      method: \"POST\",\n      body: JSON.stringify(newVote),\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n  const info: any = await res.json();\n  console.log(info);\n};\n","import { User } from \"./user\";\nimport { ITopicHeader, fetchList } from \"./database\";\nimport { useEffect, useState } from \"react\";\nimport TitleBar from \"./TitleBar\";\nimport Canvas from \"./Canvas\";\n\ninterface ListViewProps {\n  user: User;\n}\n\nconst ListView = ({ user }: ListViewProps) => {\n  const [list, setList] = useState<ITopicHeader[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isEmpty, setIsEmpty] = useState(true);\n\n  useEffect(() => {\n    const getList = async () => {\n      const newList = await fetchList();\n\t  setIsLoading(false);\n      if (newList.length > 0) {\n        setIsEmpty(false);\n        setList(newList);\n      }\n    };\n    getList();\n  }, []);\n\n  const renderList = (items: ITopicHeader[]) => (\n      <div>\n        <h1 className=\"px-4 text-bold\">topics:</h1>\n        <ul className=\"p-4 w-3/5\">\n          {items.map((item) => (\n            <li className=\"mb-1\">\n              <a\n                className=\"duration-500 ease-out p-4 flex space-x-4 bg-nord-1 hover:bg-nord-2\"\n                href={`?t=${item.id}`}\n              >\n                {item.title}\n              </a>\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n\n  return (\n    <>\n      <TitleBar />\n      <div className=\"container max-w-screen-lg py-8 mx-auto bg-nord-0 bg-opacity-90 min-h-1/4 rounded\">\n\t\t  {isLoading ? (\n\t\t\t  <div className=\"p-4\">Loading topics...</div>\n\t\t  ) : (isEmpty ? (\n          <div className=\"p-4\">0 topics. Nothing to vote.</div>\n        ) : (\n          renderList(list)\n        ))}\n        \n      </div>\n      <Canvas />\n    </>\n  );\n};\n\nexport default ListView;\n","import { User } from \"./user\";\nimport { updateVote, ITopicData } from \"./database\";\nimport { useState } from \"react\";\n\ninterface VotingFormsProps {\n  info: ITopicData;\n  initialVotes: { [to: string]: number };\n  user: User;\n  id: string;\n}\n\nconst VotingForms = ({ info, initialVotes, user, id }: VotingFormsProps) => {\n  const [votes, setVotes] = useState(initialVotes);\n\n  const getString = (uuid: string): string => {\n    return Object.keys(info.delegates).includes(uuid)\n      ? info.delegates[uuid]\n      : info.policies[uuid];\n  };\n\n  const handleChange = (uuid: string) => {\n    const handeChangeUuid = (e: React.ChangeEvent<HTMLInputElement>) => {\n      let value = parseFloat(e.target.value);\n\n      if (!value) {\n        value = 0.0;\n      }\n\n      if (value < 1) {\n        value = 0.0;\n      }\n\n      let newVotes = { ...votes, [uuid]: value };\n      setVotes(newVotes);\n    };\n\n    return handeChangeUuid;\n  };\n\n  const handleIncrementValueButton = (uuid: string, inc: boolean) => {\n    const handleIncrement = () => {\n      const value = inc ? 1 : -1;\n\n      let newvalue = votes[uuid] + value;\n\n      if (newvalue < 0) {\n        newvalue = 0;\n      }\n\n      let newvotes = { ...votes, [uuid]: newvalue };\n      setVotes(newvotes);\n    };\n\n    return handleIncrement;\n  };\n\n  const renderOptions = () => {\n    return Object.keys(votes).map((k) => (\n      <div className=\"ml-3 mb-3 p-2 flex flex-row bg-nord-0 bg-opacity-50 rounded\">\n        <div className=\"flex items-center justify-center font-medium\">\n          {getString(k)}\n        </div>\n        <div className=\"flex-grow\"></div>\n        <div className=\"inline-flex\">\n          <button\n            className=\"font-bold px-3 bg-nord-1 hover:bg-nord-3 rounded-l\"\n            onClick={handleIncrementValueButton(k, false)}\n          >\n            -\n          </button>\n          <input\n            className=\"px-3 py-1 w-12 text-nord-0 bg-nord-4 font-medium\"\n            onChange={handleChange(k)}\n            value={votes[k]}\n          />\n          <button\n            className=\"font-bold px-3 bg-nord-1 hover:bg-nord-3 rounded-r\"\n            onClick={handleIncrementValueButton(k, true)}\n          >\n            +\n          </button>\n          {/*\n          <button className=\"rounded px-3 ml-3 bg-nord-11 bg-opacity-70 hover:bg-opacity-90\">\n            x\n\t\t  </button>*/}\n        </div>\n      </div>\n    ));\n  };\n\n  const handleSubmit = () => {\n    const update = async () => updateVote(id, user.uid, user.name, votes);\n    update();\n  };\n\n  return (\n    <div className=\"container mx-auto max-w-screen-lg p-3\">\n      <div className=\"w-3/5\">{renderOptions()}</div>\n      {/*\n      <div className=\"w-3/5 grid justify-items-end\">\n\t\t  <button className=\"p-2 rounded bg-nord-0 hover:bg-nord-2\">\n          Add New Option\n\t\t  </button>\n\t\t  </div>*/}\n      <div className=\"mt-3 w-3/5 grid justify-items-end\">\n        <button\n          className=\"p-2 rounded border bg-nord-9 font-bold text-nord-0 hover:bg-nord-10 bg-opacity-80 duration-500 ease-in\"\n          onClick={handleSubmit}\n        >\n          Update vote\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default VotingForms;\n","import {ITopicData} from \"./database\";\n\nexport const baseUrl = \"https://vote.metacity.jp\";\n\nexport const vote = async (topicData: ITopicData) => {\n\n  const response = await fetch(`${baseUrl}/rpc/`, {\n    // mode: \"cors\",\n    method: \"POST\",\n    body: JSON.stringify(topicData),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n  const data: {[method: string]: any} = await response.json();\n\n  return data;\n};\n","import { useEffect, useState } from \"react\";\nimport { vote } from \"./vote\";\nimport { ITopicData, fetchResult, postResult, fetchHeader, fetchTopicData } from \"./database\";\n\ninterface VotingResultsProps {\n  info: ITopicData;\n  hash: string;\n}\n\nconst VotingResults = ({ info, hash }: VotingResultsProps) => {\n  let [result, setResult] = useState(\"\");\n  useEffect(() => {\n\n    const checkResult = async () => {\n\n\t\t// get the latest header;\n\t\tlet header = await fetchHeader(info.id);\n\n\t\tconst fetched = await fetchResult(header.hash);\n\n\t\tif(fetched.status === 'error') {\n\t\t\tsetResult(\"result not found in database. sending calculation result to `vote`.\");\n\n\t\t\tlet latest = await fetchTopicData(header.id);\n\t\t\t\t\t\t\n\t\t\tlet calculated = await vote(latest);\n\n\t\t\tsetResult(JSON.stringify(calculated, null, 2));\n\n\t\t} else {\n\t\t\tsetResult(JSON.stringify(fetched, null, 2))\n\t\t}\n\t\t\n    };\n\n    checkResult();\n  }, [hash, info]);\n\n  return (\n    <>\n      <details className=\"text-sm p-2 mt-4\">\n        <summary className=\"p-3 bg-nord-0 bg-opacity-10 border border-nord-3 rounded w-3/5\">\n          Results\n        </summary>\n        <pre className=\"bg-nord-0 bg-opacity-90 text-xs p-3 mt-3 rounded w-3/5\">\n          {result}\n        </pre>\n        <button className=\"mt-3 mb-8 p-2 rounded border bg-nord-9 font-bold text-nord-0 hover:bg-nord-10 bg-opacity-80 duration-500 ease-in\">\n          Update\n        </button>\n      </details>\n    </>\n  );\n};\n\nexport default VotingResults;\n","import { ITopicData } from \"./database\";\nimport { User } from \"./user\";\nimport VotingForms from \"./VotingForms\";\nimport VotingResults from \"./VotingResults\";\nimport TitleBar from \"./TitleBar\";\nimport Canvas from \"./Canvas\";\n\ninterface VotingInfoProp {\n  info: ITopicData;\n  user: User;\n  hash: string;\n}\n\nconst VotingInfo = ({ info, user, hash }: VotingInfoProp) => {\n  const getOptions = (): { [to: string]: number } => {\n    let options: { [to: string]: number } = {};\n\n    Object.keys(info.policies).forEach((to) => (options[to] = 0.0));\n    Object.keys(info.delegates).forEach((to) => (options[to] = 0.0));\n\n    // fill in the current value\n    const userVotes = info.votes[user.uid];\n    if (userVotes) {\n      Object.keys(userVotes).forEach((to) => (options[to] = userVotes[to]));\n    }\n\n\tdelete options[user.uid];\n\n    return options;\n  };\n\n  return (\n    <>\n      <TitleBar />\n      <div className=\"container max-w-screen-lg mx-auto\">\n        <h1 className=\"font-bold p-2\">{info.title}</h1>\n        <details className=\"text-sm p-2 mb-4\">\n          <summary className=\"p-3 bg-nord-0 bg-opacity-10 border border-nord-3 rounded w-3/5\">\n            Details\n          </summary>\n          <p className=\"bg-nord-0 bg-opacity-90 text-xs p-3 mt-3 rounded w-3/5\">\n            {info.description}\n          </p>\n        </details>\n        <details open className=\"p-2\">\n          <summary className=\"p-3 bg-nord-0 bg-opacity-10 border border-nord-3 rounded w-3/5 text-sm\">\n            Votes\n          </summary>\n\n          <VotingForms\n            info={info}\n            initialVotes={getOptions()}\n            user={user}\n            id={info.id}\n          />\n        </details>\n        <VotingResults info={info} hash={hash} />\n      </div>\n      <Canvas />\n    </>\n  );\n};\n\nexport default VotingInfo;\n","import { useEffect, useState } from \"react\";\nimport VotingInfo from \"./VotingInfo\";\nimport { fetchTopicData, ITopicData, fetchHeader, ITopicHeader } from \"./database\";\nimport { User } from \"./user\";\nimport TitleBar from \"./TitleBar\";\n\ninterface VotingSessionProps {\n  id: string;\n  user: User;\n}\n\nconst VotingSession = ({ id, user }: VotingSessionProps) => {\n  const [info, setInfo] = useState<null | ITopicData>(null);\n  const [hash, setHash] = useState(\"\");\n  useEffect(() => {\n    const getInfo = async () => {\n      let latestInfo: ITopicData = await fetchTopicData(id);\n\t  let header: ITopicHeader = await fetchHeader(id);\n\t  setHash(header.hash);\n      setInfo(latestInfo);\n    };\n    getInfo();\n  }, [id]);\n\n  if (info) {\n    return <VotingInfo info={info} user={user} hash={hash}/>;\n  } else {\n    return (\n      <div>\n        <TitleBar/>\n        <div className=\"container mx-auto max-w-screen-lg p-2\">\n\t\t\tLoading Topic (#{id.substring(0,5)}) information...\n        </div>\n      </div>\n    );\n  }\n};\n\nexport default VotingSession;\n","import { User, checkSavedUser } from \"./user\";\nimport MakeNewUser from \"./MakeNewUser\";\nimport \"./App.css\";\nimport ListView from \"./ListView\";\nimport VotingSession from \"./VotingSession\";\nimport { useEffect, useState } from \"react\";\n\nconst App = () => {\n  const [user, setUser] = useState<null | User>(null);\n\n  useEffect(() => {\n    let savedUser = checkSavedUser();\n    setUser(savedUser);\n  }, []);\n\n  // first make sure we have a user\n  if (!user) {\n    return <MakeNewUser />;\n  }\n\n  const topicId = checkParams(\"t\");\n\n  if (!topicId) {\n    return <ListView user={user} />;\n  }\n\n  return <VotingSession id={topicId} user={user} />;\n};\n\nconst checkParams = (p: string): string | null => {\n  let cUrl = window.location.search;\n  const params = new URLSearchParams(cUrl);\n  return params.get(p);\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}